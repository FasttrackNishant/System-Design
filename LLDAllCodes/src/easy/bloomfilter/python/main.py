
class HashType(Enum):
    FNV1A = "FNV1A"
    DJB2 = "DJB2"



class HashStrategyFactory:
    @staticmethod
    def create(hash_type: HashType) -> HashStrategy:
        if hash_type == HashType.FNV1A:
            return FNV1aHashStrategy()
        elif hash_type == HashType.DJB2:
            return DJB2HashStrategy()
        else:
            raise ValueError(f"Unsupported hash type: {hash_type}")






class DJB2HashStrategy(HashStrategy):
    def hash(self, data: str) -> int:
        hash_value = 5381
        for byte in data.encode('utf-8'):
            # hash = hash * 33 + c
            hash_value = ((hash_value << 5) + hash_value) + byte
        return hash_value





class FNV1aHashStrategy(HashStrategy):
    # FNV-1a 64-bit constants
    FNV_PRIME = 0x100000001b3
    FNV_OFFSET_BASIS = 0xcbf29ce484222325

    def hash(self, data: str) -> int:
        hash_value = self.FNV_OFFSET_BASIS
        for byte in data.encode('utf-8'):
            hash_value ^= byte
            hash_value *= self.FNV_PRIME
        return hash_value





class HashStrategy(ABC):
    @abstractmethod
    def hash(self, data: str) -> int:
        pass





class BloomFilterDemo:
    @staticmethod
    def main():
        # --- 1. Manually define parameters ---
        bit_set_size = 10000
        num_hash_functions = 2
        expected_insertions = 1000

        # --- 2. Create a list of hash strategies at runtime ---
        # We use the Factory to get base strategies and the Decorator to create unique variations.
        strategies = [
            HashStrategyFactory.create(HashType.FNV1A),
            HashStrategyFactory.create(HashType.DJB2)
        ]

        # --- 3. Build the filter using the new Builder syntax ---
        filter = BloomFilter.Builder() \
            .with_bit_set_size(bit_set_size) \
            .with_num_hash_functions(num_hash_functions) \
            .with_hash_strategies(strategies) \
            .build()

        # --- 4. Add elements to the filter ---
        print("\n--- Adding elements to the filter ---")
        inserted_elements = []
        for i in range(expected_insertions):
            element = f"user{i}@example.com"
            inserted_elements.append(element)
            filter.add(element)
        print(f"{expected_insertions} elements have been added.")

        # --- 5. Test for presence (no false negatives) ---
        print("\n--- Verifying no false negatives ---")
        has_false_negatives = False
        for element in inserted_elements:
            if not filter.might_contain(element):
                print(f"FALSE NEGATIVE DETECTED FOR: {element}", file=sys.stderr)
                has_false_negatives = True
                break
        if not has_false_negatives:
            print("Success! No false negatives found. All inserted elements were detected.")

        # --- 6. Test for false positives ---
        print("\n--- Testing for false positives ---")
        test_set_size = 10000
        false_positives_count = 0
        for i in range(test_set_size):
            random_element = str(uuid.uuid4())
            if filter.might_contain(random_element):
                false_positives_count += 1
        print(f"Number of false positives found: {false_positives_count} out of {test_set_size} random items.")

if __name__ == "__main__":
    BloomFilterDemo.main()




class BloomFilter:
    def __init__(self, bit_set_size: int, num_hash_functions: int, hash_strategies: List[HashStrategy]):
        self.bit_set_size = bit_set_size
        self.num_hash_functions = num_hash_functions
        self.bit_set = [False] * bit_set_size
        self.hash_strategies = hash_strategies

    def add(self, item: str):
        for i in range(self.num_hash_functions):
            hash_value = self.hash_strategies[i].hash(item)
            index = abs(hash_value) % self.bit_set_size
            self.bit_set[index] = True

    def might_contain(self, item: str) -> bool:
        for i in range(self.num_hash_functions):
            hash_value = self.hash_strategies[i].hash(item)
            index = abs(hash_value) % self.bit_set_size
            if not self.bit_set[index]:
                return False  # Definitely not in the set
        return True  # Might be in the set

    class Builder:
        def __init__(self):
            self.bit_set_size = 0
            self.num_hash_functions = 0
            self.strategies = None

        def with_bit_set_size(self, bit_set_size: int):
            if bit_set_size <= 0:
                raise ValueError("Bit set size must be positive.")
            self.bit_set_size = bit_set_size
            return self

        def with_num_hash_functions(self, num_hash_functions: int):
            if num_hash_functions <= 0:
                raise ValueError("Number of hash functions must be positive.")
            self.num_hash_functions = num_hash_functions
            return self

        def with_hash_strategies(self, strategies: List[HashStrategy]):
            if strategies is None or len(strategies) == 0:
                raise ValueError("At least one hash strategy must be provided.")
            self.strategies = strategies
            return self

        def build(self) -> 'BloomFilter':
            if self.bit_set_size == 0 or self.num_hash_functions == 0 or self.strategies is None:
                raise RuntimeError("Must set bit set size, number of hash functions, and strategies.")

            if len(self.strategies) < self.num_hash_functions:
                raise RuntimeError(
                    f"The number of provided hash strategies ({len(self.strategies)}) "
                    f"must be at least equal to the number of hash functions required ({self.num_hash_functions})."
                )

            print(f"Creating Bloom Filter with specified parameters:")
            print(f"  - Bit set size (m): {self.bit_set_size}")
            print(f"  - Hash functions (k): {self.num_hash_functions}")

            return BloomFilter(self.bit_set_size, self.num_hash_functions, self.strategies)

































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































