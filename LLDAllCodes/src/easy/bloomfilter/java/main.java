package easy.snakeandladder.java;

enum HashType {
    FNV1A,
    DJB2
}




class HashStrategyFactory {
    public static HashStrategy create(HashType type) {
        switch (type) {
            case FNV1A:
                return new FNV1aHashStrategy();
            case DJB2:
                return new DJB2HashStrategy();
            default:
                throw new IllegalArgumentException("Unsupported hash type: " + type);
        }
    }
}



class DJB2HashStrategy implements HashStrategy {
    @Override
    public long hash(String data) {
        long hash = 5381L;
        for (byte b : data.getBytes(StandardCharsets.UTF_8)) {
            // hash = hash * 33 + c
            hash = ((hash << 5) + hash) + b;
        }
        return hash;
    }
}






class FNV1aHashStrategy implements HashStrategy {
    // FNV-1a 64-bit constants
    private static final long FNV_PRIME = 0x100000001b3L;
    private static final long FNV_OFFSET_BASIS = 0xcbf29ce484222325L;

    @Override
    public long hash(String data) {
        long hash = FNV_OFFSET_BASIS;
        for (byte b : data.getBytes(StandardCharsets.UTF_8)) {
            hash ^= b;
            hash *= FNV_PRIME;
        }
        return hash;
    }
}




interface HashStrategy {
    long hash(String data);
}





class BloomFilter {
    private final BitSet bitSet;
    private final int bitSetSize;
    private final int numHashFunctions;
    private final List<HashStrategy> hashStrategies;

    private BloomFilter(int bitSetSize, int numHashFunctions, List<HashStrategy> strategies) {
        this.bitSetSize = bitSetSize;
        this.numHashFunctions = numHashFunctions;
        this.bitSet = new BitSet(bitSetSize);
        this.hashStrategies = strategies;
    }

    public void add(String item) {
        for (int i = 0; i < numHashFunctions; i++) {
            long hash = hashStrategies.get(i).hash(item);
            int index = (int) (Math.abs(hash) % bitSetSize);
            bitSet.set(index);
        }
    }

    public boolean mightContain(String item) {
        for (int i = 0; i < numHashFunctions; i++) {
            long hash = hashStrategies.get(i).hash(item);
            int index = (int) (Math.abs(hash) % bitSetSize);
            if (!bitSet.get(index)) {
                return false; // Definitely not in the set
            }
        }
        return true; // Might be in the set
    }

    public static class Builder {
        private int bitSetSize;
        private int numHashFunctions;
        private List<HashStrategy> strategies;

        public Builder withBitSetSize(int bitSetSize) {
            if (bitSetSize <= 0) {
                throw new IllegalArgumentException("Bit set size must be positive.");
            }
            this.bitSetSize = bitSetSize;
            return this;
        }

        public Builder withNumHashFunctions(int numHashFunctions) {
            if (numHashFunctions <= 0) {
                throw new IllegalArgumentException("Number of hash functions must be positive.");
            }
            this.numHashFunctions = numHashFunctions;
            return this;
        }

        public Builder withHashStrategies(List<HashStrategy> strategies) {
            if (strategies == null || strategies.isEmpty()) {
                throw new IllegalArgumentException("At least one hash strategy must be provided.");
            }
            this.strategies = strategies;
            return this;
        }

        public BloomFilter build() {
            if (bitSetSize == 0 || numHashFunctions == 0 || strategies == null) {
                throw new IllegalStateException("Must set bit set size, number of hash functions, and strategies.");
            }

            if (strategies.size() < numHashFunctions) {
                throw new IllegalStateException(
                        "The number of provided hash strategies (" + strategies.size() + ") " +
                                "must be at least equal to the number of hash functions required (" + numHashFunctions + ")."
                );
            }

            System.out.printf("Creating Bloom Filter with specified parameters:%n" +
                    "  - Bit set size (m): %d%n" +
                    "  - Hash functions (k): %d%n", bitSetSize, numHashFunctions);

            return new BloomFilter(bitSetSize, numHashFunctions, strategies);
        }
    }
}









import java.util.*;
import java.nio.charset.StandardCharsets;

public class BloomFilterDemo {
    public static void main(String[] args) {
        // --- 1. Manually define parameters ---
        int bitSetSize = 10000;
        int numHashFunctions = 2;
        int expectedInsertions = 1000;

        // --- 2. Create a list of hash strategies at runtime ---
        // We use the Factory to get base strategies and the Decorator to create unique variations.
        List<HashStrategy> strategies = List.of(
                HashStrategyFactory.create(HashType.FNV1A),
                HashStrategyFactory.create(HashType.DJB2)
        );

        // --- 3. Build the filter using the new Builder syntax ---
        BloomFilter filter = new BloomFilter.Builder()
                .withBitSetSize(bitSetSize)
                .withNumHashFunctions(numHashFunctions)
                .withHashStrategies(strategies)
                .build();

        // --- 4. Add elements to the filter ---
        System.out.println("\n--- Adding elements to the filter ---");
        List<String> insertedElements = new ArrayList<>();
        for (int i = 0; i < expectedInsertions; i++) {
            String element = "user" + i + "@example.com";
            insertedElements.add(element);
            filter.add(element);
        }
        System.out.println(expectedInsertions + " elements have been added.");

        // --- 5. Test for presence (no false negatives) ---
        System.out.println("\n--- Verifying no false negatives ---");
        boolean hasFalseNegatives = false;
        for (String element : insertedElements) {
            if (!filter.mightContain(element)) {
                System.err.println("FALSE NEGATIVE DETECTED FOR: " + element);
                hasFalseNegatives = true;
                break;
            }
        }
        if (!hasFalseNegatives) {
            System.out.println("Success! No false negatives found. All inserted elements were detected.");
        }

        // --- 6. Test for false positives ---
        System.out.println("\n--- Testing for false positives ---");
        int testSetSize = 10000;
        int falsePositivesCount = 0;
        for (int i = 0; i < testSetSize; i++) {
            String randomElement = UUID.randomUUID().toString();
            if (filter.mightContain(randomElement)) {
                falsePositivesCount++;
            }
        }
        System.out.println("Number of false positives found: " + falsePositivesCount + " out of " + testSetSize + " random items.");
    }
}




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































