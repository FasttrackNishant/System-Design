


enum class HashType {
    FNV1A,
    DJB2
};



class HashStrategyFactory {
public:
    static unique_ptr<HashStrategy> create(HashType type) {
        switch (type) {
            case HashType::FNV1A:
                return make_unique<FNV1aHashStrategy>();
            case HashType::DJB2:
                return make_unique<DJB2HashStrategy>();
            default:
                throw invalid_argument("Unsupported hash type");
        }
    }
};




class DJB2HashStrategy : public HashStrategy {
public:
    long hash(const string& data) override {
        long hash_value = 5381L;
        for (char c : data) {
            hash_value = ((hash_value << 5) + hash_value) + static_cast<unsigned char>(c);
        }
        return hash_value;
    }
};





class FNV1aHashStrategy : public HashStrategy {
private:
    static const long FNV_PRIME = 0x100000001b3L;
    static const long FNV_OFFSET_BASIS = 0xcbf29ce484222325L;

public:
    long hash(const string& data) override {
        long hash_value = FNV_OFFSET_BASIS;
        for (char c : data) {
            hash_value ^= static_cast<unsigned char>(c);
            hash_value *= FNV_PRIME;
        }
        return hash_value;
    }
};




class HashStrategy {
public:
    virtual ~HashStrategy() = default;
    virtual long hash(const string& data) = 0;
};






class BloomFilter {
private:
    vector<bool> bitSet;
    int bitSetSize;
    int numHashFunctions;
    vector<unique_ptr<HashStrategy>> hashStrategies;

    BloomFilter(int bitSetSize, int numHashFunctions, vector<unique_ptr<HashStrategy>> strategies)
        : bitSetSize(bitSetSize), numHashFunctions(numHashFunctions), bitSet(bitSetSize, false) {
        hashStrategies = move(strategies);
    }

public:
    void add(const string& item) {
        for (int i = 0; i < numHashFunctions; i++) {
            long hash_value = hashStrategies[i]->hash(item);
            int index = static_cast<int>(abs(hash_value) % bitSetSize);
            bitSet[index] = true;
        }
    }

    bool mightContain(const string& item) {
        for (int i = 0; i < numHashFunctions; i++) {
            long hash_value = hashStrategies[i]->hash(item);
            int index = static_cast<int>(abs(hash_value) % bitSetSize);
            if (!bitSet[index]) {
                return false;
            }
        }
        return true;
    }

    class Builder {
    private:
        int bitSetSize = 0;
        int numHashFunctions = 0;
        vector<unique_ptr<HashStrategy>> strategies;

    public:
        Builder& withBitSetSize(int bitSetSize) {
            if (bitSetSize <= 0) {
                throw invalid_argument("Bit set size must be positive.");
            }
            this->bitSetSize = bitSetSize;
            return *this;
        }

        Builder& withNumHashFunctions(int numHashFunctions) {
            if (numHashFunctions <= 0) {
                throw invalid_argument("Number of hash functions must be positive.");
            }
            this->numHashFunctions = numHashFunctions;
            return *this;
        }

        Builder& withHashStrategies(vector<unique_ptr<HashStrategy>> strategies) {
            if (strategies.empty()) {
                throw invalid_argument("At least one hash strategy must be provided.");
            }
            this->strategies = move(strategies);
            return *this;
        }

        BloomFilter build() {
            if (bitSetSize == 0 || numHashFunctions == 0 || strategies.empty()) {
                throw runtime_error("Must set bit set size, number of hash functions, and strategies.");
            }

            if (strategies.size() < static_cast<size_t>(numHashFunctions)) {
                throw runtime_error("The number of provided hash strategies (" + 
                    to_string(strategies.size()) + ") must be at least equal to the number of hash functions required (" + 
                    to_string(numHashFunctions) + ").");
            }

            cout << "Creating Bloom Filter with specified parameters:" << endl;
            cout << "  - Bit set size (m): " << bitSetSize << endl;
            cout << "  - Hash functions (k): " << numHashFunctions << endl;

            return BloomFilter(bitSetSize, numHashFunctions, move(strategies));
        }
    };
};






class BloomFilterDemo {
public:
    static void main() {
        // --- 1. Manually define parameters ---
        int bitSetSize = 10000;
        int numHashFunctions = 2;
        int expectedInsertions = 1000;

        // --- 2. Create a list of hash strategies at runtime ---
        vector<unique_ptr<HashStrategy>> strategies;
        strategies.push_back(HashStrategyFactory::create(HashType::FNV1A));
        strategies.push_back(HashStrategyFactory::create(HashType::DJB2));

        // --- 3. Build the filter using the new Builder syntax ---
        BloomFilter filter = BloomFilter::Builder()
            .withBitSetSize(bitSetSize)
            .withNumHashFunctions(numHashFunctions)
            .withHashStrategies(move(strategies))
            .build();

        // --- 4. Add elements to the filter ---
        cout << "\n--- Adding elements to the filter ---" << endl;
        vector<string> insertedElements;
        for (int i = 0; i < expectedInsertions; i++) {
            string element = "user" + to_string(i) + "@example.com";
            insertedElements.push_back(element);
            filter.add(element);
        }
        cout << expectedInsertions << " elements have been added." << endl;

        // --- 5. Test for presence (no false negatives) ---
        cout << "\n--- Verifying no false negatives ---" << endl;
        bool hasFalseNegatives = false;
        for (const string& element : insertedElements) {
            if (!filter.mightContain(element)) {
                cerr << "FALSE NEGATIVE DETECTED FOR: " << element << endl;
                hasFalseNegatives = true;
                break;
            }
        }
        if (!hasFalseNegatives) {
            cout << "Success! No false negatives found. All inserted elements were detected." << endl;
        }

        // --- 6. Test for false positives ---
        cout << "\n--- Testing for false positives ---" << endl;
        int testSetSize = 10000;
        int falsePositivesCount = 0;
        for (int i = 0; i < testSetSize; i++) {
            string randomElement = generateUUID();
            if (filter.mightContain(randomElement)) {
                falsePositivesCount++;
            }
        }
        cout << "Number of false positives found: " << falsePositivesCount << " out of " << testSetSize << " random items." << endl;
    }
};

int main() {
    BloomFilterDemo::main();
    return 0;
}































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































