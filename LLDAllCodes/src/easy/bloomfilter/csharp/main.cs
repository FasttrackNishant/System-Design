


class BloomFilterBuilder
{
    private int bitSetSize;
    private int numHashFunctions;
    private List<IHashStrategy> strategies;

    public BloomFilterBuilder WithBitSetSize(int bitSetSize)
    {
        if (bitSetSize <= 0)
        {
            throw new ArgumentException("Bit set size must be positive.");
        }
        this.bitSetSize = bitSetSize;
        return this;
    }

    public BloomFilterBuilder WithNumHashFunctions(int numHashFunctions)
    {
        if (numHashFunctions <= 0)
        {
            throw new ArgumentException("Number of hash functions must be positive.");
        }
        this.numHashFunctions = numHashFunctions;
        return this;
    }

    public BloomFilterBuilder WithHashStrategies(List<IHashStrategy> strategies)
    {
        if (strategies == null || strategies.Count == 0)
        {
            throw new ArgumentException("At least one hash strategy must be provided.");
        }
        this.strategies = strategies;
        return this;
    }

    public BloomFilter Build()
    {
        if (bitSetSize == 0 || numHashFunctions == 0 || strategies == null)
        {
            throw new InvalidOperationException("Must set bit set size, number of hash functions, and strategies.");
        }

        if (strategies.Count < numHashFunctions)
        {
            throw new InvalidOperationException(
                "The number of provided hash strategies (" + strategies.Count + ") " +
                "must be at least equal to the number of hash functions required (" + numHashFunctions + ")."
            );
        }

        Console.WriteLine("Creating Bloom Filter with specified parameters:");
        Console.WriteLine("  - Bit set size (m): " + bitSetSize);
        Console.WriteLine("  - Hash functions (k): " + numHashFunctions);

        return new BloomFilter(bitSetSize, numHashFunctions, strategies);
    }
}







enum BloomHashType
{
    FNV1A,
    DJB2
}









class HashStrategyFactory
{
    public static IHashStrategy Create(BloomHashType type)
    {
        switch (type)
        {
            case BloomHashType.FNV1A:
                return new FnvHashStrategy();
            case BloomHashType.DJB2:
                return new DJB2HashStrategy();
            default:
                throw new ArgumentException("Unsupported hash type: " + type);
        }
    }
}








class DJB2HashStrategy : IHashStrategy
{
    public long Hash(string data)
    {
        long hash = 5381L;
        foreach (byte b in Encoding.UTF8.GetBytes(data))
        {
            hash = ((hash << 5) + hash) + b;
        }
        return hash;
    }
}






class FnvHashStrategy : IHashStrategy
{
    private const ulong FNV_PRIME = 0x100000001b3;
    private const ulong FNV_OFFSET_BASIS = 0xcbf29ce484222325;

    public long Hash(string data)
    {
        ulong hash = FNV_OFFSET_BASIS;
        foreach (byte b in Encoding.UTF8.GetBytes(data))
        {
            hash ^= b;
            hash *= FNV_PRIME;
        }
        return (long)hash;
    }
}








interface IHashStrategy
{
    long Hash(string data);
}




class BloomFilter
{
    private readonly BitArray bitSet;
    private readonly int bitSetSize;
    private readonly int numHashFunctions;
    private readonly List<IHashStrategy> hashStrategies;

    public BloomFilter(int bitSetSize, int numHashFunctions, List<IHashStrategy> strategies)
    {
        this.bitSetSize = bitSetSize;
        this.numHashFunctions = numHashFunctions;
        this.bitSet = new BitArray(bitSetSize);
        this.hashStrategies = strategies;
    }

    public void Add(string item)
    {
        for (int i = 0; i < numHashFunctions; i++)
        {
            long hash = hashStrategies[i].Hash(item);
            int index = (int)(Math.Abs(hash) % bitSetSize);
            bitSet[index] = true;
        }
    }

    public bool MightContain(string item)
    {
        for (int i = 0; i < numHashFunctions; i++)
        {
            long hash = hashStrategies[i].Hash(item);
            int index = (int)(Math.Abs(hash) % bitSetSize);
            if (!bitSet[index])
            {
                return false;
            }
        }
        return true;
    }
}





using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;

public class BloomFilterDemo
{
    public static void Main(string[] args)
    {
        // --- 1. Manually define parameters ---
        int bitSetSize = 10000;
        int numHashFunctions = 2;
        int expectedInsertions = 1000;

        // --- 2. Create a list of hash strategies at runtime ---
        List<IHashStrategy> strategies = new List<IHashStrategy>
        {
            HashStrategyFactory.Create(BloomHashType.FNV1A),
            HashStrategyFactory.Create(BloomHashType.DJB2)
        };

        // --- 3. Build the filter using the new Builder syntax ---
        BloomFilter filter = new BloomFilterBuilder()
            .WithBitSetSize(bitSetSize)
            .WithNumHashFunctions(numHashFunctions)
            .WithHashStrategies(strategies)
            .Build();

        // --- 4. Add elements to the filter ---
        Console.WriteLine("\n--- Adding elements to the filter ---");
        List<string> insertedElements = new List<string>();
        for (int i = 0; i < expectedInsertions; i++)
        {
            string element = "user" + i + "@example.com";
            insertedElements.Add(element);
            filter.Add(element);
        }
        Console.WriteLine(expectedInsertions + " elements have been added.");

        // --- 5. Test for presence (no false negatives) ---
        Console.WriteLine("\n--- Verifying no false negatives ---");
        bool hasFalseNegatives = false;
        foreach (string element in insertedElements)
        {
            if (!filter.MightContain(element))
            {
                Console.Error.WriteLine("FALSE NEGATIVE DETECTED FOR: " + element);
                hasFalseNegatives = true;
                break;
            }
        }
        if (!hasFalseNegatives)
        {
            Console.WriteLine("Success! No false negatives found. All inserted elements were detected.");
        }

        // --- 6. Test for false positives ---
        Console.WriteLine("\n--- Testing for false positives ---");
        int testSetSize = 10000;
        int falsePositivesCount = 0;
        for (int i = 0; i < testSetSize; i++)
        {
            string randomElement = Guid.NewGuid().ToString();
            if (filter.MightContain(randomElement))
            {
                falsePositivesCount++;
            }
        }
        Console.WriteLine("Number of false positives found: " + falsePositivesCount + " out of " + testSetSize + " random items.");
    }
}










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































