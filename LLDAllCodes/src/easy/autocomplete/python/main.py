


class AutocompleteSystemBuilder:
    def __init__(self):
        self.ranking_strategy = FrequencyBasedRanking()  # Default strategy
        self.max_suggestions = 10  # Default limit

    def with_ranking_strategy(self, strategy: RankingStrategy):
        self.ranking_strategy = strategy
        return self

    def with_max_suggestions(self, max_suggestions: int):
        self.max_suggestions = max_suggestions
        return self

    def build(self) -> AutocompleteSystem:
        return AutocompleteSystem(self.ranking_strategy, self.max_suggestions)








class Suggestion:
    def __init__(self, word: str, weight: int):
        self.word = word
        self.weight = weight

    def get_word(self) -> str:
        return self.word

    def get_weight(self) -> int:
        return self.weight








class TrieNode:
    def __init__(self):
        self.children: Dict[str, 'TrieNode'] = {}
        self.is_end_of_word: bool = False
        self.frequency: int = 0

    def get_children(self) -> Dict[str, 'TrieNode']:
        return self.children

    def is_end_of_word_check(self) -> bool:
        return self.is_end_of_word

    def set_end_of_word(self, end_of_word: bool):
        self.is_end_of_word = end_of_word

    def get_frequency(self) -> int:
        return self.frequency

    def increment_frequency(self):
        self.frequency += 1








class Trie:
    def __init__(self):
        self.root = TrieNode()

    def insert(self, word: str):
        current = self.root
        for ch in word:
            if ch not in current.get_children():
                current.get_children()[ch] = TrieNode()
            current = current.get_children()[ch]
        current.set_end_of_word(True)
        current.increment_frequency()

    def search_prefix(self, prefix: str) -> Optional[TrieNode]:
        current = self.root
        for ch in prefix:
            node = current.get_children().get(ch)
            if node is None:
                return None
            current = node
        return current

    def collect_suggestions(self, start_node: TrieNode, prefix: str) -> List[Suggestion]:
        suggestions = []
        self._collect(start_node, prefix, suggestions)
        return suggestions

    def _collect(self, node: TrieNode, current_prefix: str, suggestions: List[Suggestion]):
        if node.is_end_of_word_check():
            suggestions.append(Suggestion(current_prefix, node.get_frequency()))

        for ch in node.get_children().keys():
            self._collect(node.get_children()[ch], current_prefix + ch, suggestions)









class AlphabeticalRanking(RankingStrategy):
    def rank(self, suggestions: List[Suggestion]) -> List[Suggestion]:
        return sorted(suggestions, key=lambda s: s.get_word())




class FrequencyBasedRanking(RankingStrategy):
    def rank(self, suggestions: List[Suggestion]) -> List[Suggestion]:
        return sorted(suggestions, key=lambda s: s.get_weight(), reverse=True)







class RankingStrategy(ABC):
    @abstractmethod
    def rank(self, suggestions: List[Suggestion]) -> List[Suggestion]:
        pass









def main():
    print("----------- SCENARIO 1: Frequency-based Ranking -----------")

    # 1. Build the system with the default frequency-based strategy
    system_by_frequency = (AutocompleteSystemBuilder()
                          .with_max_suggestions(5)
                          .with_ranking_strategy(FrequencyBasedRanking())
                          .build())

    # 2. Feed data into the system
    # 'canada' is added most frequently, followed by 'car'
    dictionary = [
        "car", "cat", "cart", "cartoon", "canada", "candy",
        "car", "canada", "canada", "car", "canada", "canopy", "captain"
    ]
    system_by_frequency.add_words(dictionary)

    # 3. Get suggestions for a prefix
    prefix1 = "ca"
    suggestions1 = system_by_frequency.get_suggestions(prefix1)
    print(f"Suggestions for '{prefix1}': {suggestions1}")

    prefix2 = "car"
    suggestions2 = system_by_frequency.get_suggestions(prefix2)
    print(f"Suggestions for '{prefix2}': {suggestions2}")

    print("\n----------- SCENARIO 2: Alphabetical Ranking -----------")

    # 1. Build a new system with the alphabetical strategy
    system_alphabetical = (AutocompleteSystemBuilder()
                          .with_ranking_strategy(AlphabeticalRanking())
                          .build())

    # 2. Feed the same data
    system_alphabetical.add_words(dictionary)

    # 3. Get suggestions for the same prefix
    suggestions3 = system_alphabetical.get_suggestions(prefix1)
    print(f"Suggestions for '{prefix1}' (alphabetical): {suggestions3}")

if __name__ == "__main__":
    main()







class AutocompleteSystem:
    def __init__(self, ranking_strategy: RankingStrategy, max_suggestions: int):
        self.trie = Trie()
        self.ranking_strategy = ranking_strategy
        self.max_suggestions = max_suggestions

    def add_word(self, word: str):
        self.trie.insert(word.lower())

    def add_words(self, words: List[str]):
        for word in words:
            self.add_word(word)

    def get_suggestions(self, prefix: str) -> List[str]:
        prefix_node = self.trie.search_prefix(prefix.lower())
        if prefix_node is None:
            return []

        raw_suggestions = self.trie.collect_suggestions(prefix_node, prefix.lower())
        ranked_suggestions = self.ranking_strategy.rank(raw_suggestions)

        return [s.get_word() for s in ranked_suggestions[:self.max_suggestions]]


























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































