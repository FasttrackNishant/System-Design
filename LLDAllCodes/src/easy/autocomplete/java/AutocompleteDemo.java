package easy.snakeandladder.java;

class AutocompleteSystemBuilder {
    private RankingStrategy rankingStrategy = new FrequencyBasedRanking(); // Default strategy
    private int maxSuggestions = 10; // Default limit

    public AutocompleteSystemBuilder withRankingStrategy(RankingStrategy strategy) {
        this.rankingStrategy = strategy;
        return this;
    }

    public AutocompleteSystemBuilder withMaxSuggestions(int max) {
        this.maxSuggestions = max;
        return this;
    }

    public AutocompleteSystem build() {
        return new AutocompleteSystem(rankingStrategy, maxSuggestions);
    }
}





class Suggestion {
    private final String word;
    private final int weight;

    public Suggestion(String word, int weight) {
        this.word = word;
        this.weight = weight;
    }

    public String getWord() {
        return word;
    }

    public int getWeight() {
        return weight;
    }
}




class Trie {
    private final TrieNode root;

    public Trie() {
        root = new TrieNode();
    }

    public void insert(String word) {
        TrieNode current = root;
        for (char ch : word.toCharArray()) {
            current = current.getChildren().computeIfAbsent(ch, c -> new TrieNode());
        }
        current.setEndOfWord(true);
        current.incrementFrequency();
    }

    public TrieNode searchPrefix(String prefix) {
        TrieNode current = root;
        for (char ch : prefix.toCharArray()) {
            TrieNode node = current.getChildren().get(ch);
            if (node == null) {
                return null;
            }
            current = node;
        }
        return current;
    }

    public List<Suggestion> collectSuggestions(TrieNode startNode, String prefix) {
        List<Suggestion> suggestions = new ArrayList<>();
        collect(startNode, prefix, suggestions);
        return suggestions;
    }

    private void collect(TrieNode node, String currentPrefix, List<Suggestion> suggestions) {
        if (node.isEndOfWord()) {
            suggestions.add(new Suggestion(currentPrefix, node.getFrequency()));
        }

        for (Character ch : node.getChildren().keySet()) {
            collect(node.getChildren().get(ch), currentPrefix + ch, suggestions);
        }
    }
}






class TrieNode {
    private final Map<Character, TrieNode> children = new HashMap<>();
    private boolean isEndOfWord;
    private int frequency;

    Map<Character, TrieNode> getChildren() {
        return children;
    }

    boolean isEndOfWord() {
        return isEndOfWord;
    }

    void setEndOfWord(boolean endOfWord) {
        isEndOfWord = endOfWord;
    }

    int getFrequency() {
        return frequency;
    }

    void incrementFrequency() {
        this.frequency++;
    }
}









class AlphabeticalRanking implements RankingStrategy {
    @Override
    public List<Suggestion> rank(List<Suggestion> suggestions) {
        return suggestions.stream()
                .sorted(Comparator.comparing(Suggestion::getWord))
                .collect(Collectors.toList());
    }
}




class FrequencyBasedRanking implements RankingStrategy {
    @Override
    public List<Suggestion> rank(List<Suggestion> suggestions) {
        return suggestions.stream()
                .sorted(Comparator.comparingInt(Suggestion::getWeight).reversed())
                .collect(Collectors.toList());
    }
}







interface RankingStrategy {
    List<Suggestion> rank(List<Suggestion> suggestions);
}
















import java.util.*;
import java.util.stream.Collectors;

public class AutocompleteDemo {
    public static void main(String[] args) {
        System.out.println("----------- SCENARIO 1: Frequency-based Ranking -----------");

        // 1. Build the system with the default frequency-based strategy
        AutocompleteSystem systemByFrequency = new AutocompleteSystemBuilder()
                .withMaxSuggestions(5)
                .withRankingStrategy(new FrequencyBasedRanking())
                .build();

        // 2. Feed data into the system
        // 'canada' is added most frequently, followed by 'car'
        List<String> dictionary = List.of(
                "car", "cat", "cart", "cartoon", "canada", "candy",
                "car", "canada", "canada", "car", "canada", "canopy", "captain"
        );
        systemByFrequency.addWords(dictionary);

        // 3. Get suggestions for a prefix
        String prefix1 = "ca";
        List<String> suggestions1 = systemByFrequency.getSuggestions(prefix1);
        System.out.println("Suggestions for '" + prefix1 + "': " + suggestions1);

        String prefix2 = "car";
        List<String> suggestions2 = systemByFrequency.getSuggestions(prefix2);
        System.out.println("Suggestions for '" + prefix2 + "': " + suggestions2);


        System.out.println("\n----------- SCENARIO 2: Alphabetical Ranking -----------");

        // 1. Build a new system with the alphabetical strategy
        AutocompleteSystem systemAlphabetical = new AutocompleteSystemBuilder()
                .withRankingStrategy(new AlphabeticalRanking())
                .build();

        // 2. Feed the same data
        systemAlphabetical.addWords(dictionary);

        // 3. Get suggestions for the same prefix
        List<String> suggestions3 = systemAlphabetical.getSuggestions(prefix1);
        System.out.println("Suggestions for '" + prefix1 + "' (alphabetical): " + suggestions3);
    }
}























class AutocompleteSystem {
    private final Trie trie;
    private final RankingStrategy rankingStrategy;
    private final int maxSuggestions;

    // Package-private constructor to be used by the builder
    public AutocompleteSystem(RankingStrategy rankingStrategy, int maxSuggestions) {
        this.trie = new Trie();
        this.rankingStrategy = rankingStrategy;
        this.maxSuggestions = maxSuggestions;
    }

    public void addWord(String word) {
        trie.insert(word.toLowerCase());
    }

    public void addWords(List<String> words) {
        words.forEach(this::addWord);
    }

    public List<String> getSuggestions(String prefix) {
        TrieNode prefixNode = trie.searchPrefix(prefix.toLowerCase());
        if (prefixNode == null) {
            return Collections.emptyList();
        }

        List<Suggestion> rawSuggestions = trie.collectSuggestions(prefixNode, prefix.toLowerCase());
        List<Suggestion> rankedSuggestions = rankingStrategy.rank(rawSuggestions);

        return rankedSuggestions.stream()
                .limit(maxSuggestions)
                .map(Suggestion::getWord)
                .collect(Collectors.toList());
    }
}


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































