





class DoublyLinkedList<K, V>
{
    private readonly Node<K, V> head;
    private readonly Node<K, V> tail;

    public DoublyLinkedList()
    {
        head = new Node<K, V>(default(K), default(V));
        tail = new Node<K, V>(default(K), default(V));
        head.next = tail;
        tail.prev = head;
    }

    public void AddFirst(Node<K, V> node)
    {
        node.next = head.next;
        node.prev = head;
        head.next.prev = node;
        head.next = node;
    }

    public void Remove(Node<K, V> node)
    {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    public void MoveToFront(Node<K, V> node)
    {
        Remove(node);
        AddFirst(node);
    }

    public Node<K, V> RemoveLast()
    {
        if (tail.prev == head) return null;
        Node<K, V> last = tail.prev;
        Remove(last);
        return last;
    }
}






class LRUCache<K, V>
{
    private readonly int capacity;
    private readonly Dictionary<K, Node<K, V>> map;
    private readonly DoublyLinkedList<K, V> dll;
    private readonly object lockObject = new object();

    public LRUCache(int capacity)
    {
        this.capacity = capacity;
        this.map = new Dictionary<K, Node<K, V>>();
        this.dll = new DoublyLinkedList<K, V>();
    }

    public V Get(K key)
    {
        lock (lockObject)
        {
            if (!map.ContainsKey(key)) return default(V);
            Node<K, V> node = map[key];
            dll.MoveToFront(node);
            return node.value;
        }
    }

    public void Put(K key, V value)
    {
        lock (lockObject)
        {
            if (map.ContainsKey(key))
            {
                Node<K, V> node = map[key];
                node.value = value;
                dll.MoveToFront(node);
            }
            else
            {
                if (map.Count == capacity)
                {
                    Node<K, V> lru = dll.RemoveLast();
                    if (lru != null) map.Remove(lru.key);
                }
                Node<K, V> newNode = new Node<K, V>(key, value);
                dll.AddFirst(newNode);
                map[key] = newNode;
            }
        }
    }

    public void Remove(K key)
    {
        lock (lockObject)
        {
            if (!map.ContainsKey(key)) return;
            Node<K, V> node = map[key];
            dll.Remove(node);
            map.Remove(key);
        }
    }
}







using System;
using System.Collections.Generic;

public class LRUCacheDemo
{
    public static void Main()
    {
        LRUCache<string, int> cache = new LRUCache<string, int>(3);

        cache.Put("a", 1);
        cache.Put("b", 2);
        cache.Put("c", 3);

        Console.WriteLine(cache.Get("a")); // 1

        cache.Put("d", 4);

        Console.WriteLine(cache.Get("b")); // 0 (default for int when null)
    }
}














class Node<K, V>
{
    public K key;
    public V value;
    public Node<K, V> prev;
    public Node<K, V> next;

    public Node(K key, V value)
    {
        this.key = key;
        this.value = value;
    }
}
































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































