
class LoggingObserver(TaskExecutionObserver):
    def on_task_started(self, task: ScheduledTask):
        print(f"[LOG - {datetime.now().strftime('%H:%M:%S.%f')[:-3]}] [{threading.current_thread().name}] Task {task.get_id()} started.")

    def on_task_completed(self, task: ScheduledTask):
        print(f"[LOG - {datetime.now().strftime('%H:%M:%S.%f')[:-3]}] [{threading.current_thread().name}] Task {task.get_id()} completed successfully.")

    def on_task_failed(self, task: ScheduledTask, exception: Exception):
        print(f"[LOG - {datetime.now().strftime('%H:%M:%S.%f')[:-3]}] [{threading.current_thread().name}] Task {task.get_id()} failed: {str(exception)}")







class TaskExecutionObserver(ABC):
    @abstractmethod
    def on_task_started(self, task: ScheduledTask):
        pass

    @abstractmethod
    def on_task_completed(self, task: ScheduledTask):
        pass

    @abstractmethod
    def on_task_failed(self, task: ScheduledTask, exception: Exception):
        pass





class OneTimeSchedulingStrategy(SchedulingStrategy):
    def __init__(self, execution_time: datetime):
        self.execution_time = execution_time

    def get_next_execution_time(self, last_execution_time: Optional[datetime]) -> Optional[datetime]:
        return self.execution_time if last_execution_time is None else None





class RecurringSchedulingStrategy(SchedulingStrategy):
    def __init__(self, interval: timedelta):
        self.interval = interval

    def get_next_execution_time(self, last_execution_time: Optional[datetime]) -> Optional[datetime]:
        base_time = datetime.now() if last_execution_time is None else last_execution_time
        return base_time + self.interval






class SchedulingStrategy(ABC):
    @abstractmethod
    def get_next_execution_time(self, last_execution_time: Optional[datetime]) -> Optional[datetime]:
        pass








class DataBackupTask(Task):
    def __init__(self, source: str, destination: str):
        self.source = source
        self.destination = destination

    def execute(self):
        print(f"[{datetime.now().strftime('%H:%M:%S.%f')[:-3]}] Executing DataBackupTask: Backing up from {self.source} to {self.destination}...")
        print(f"[{datetime.now().strftime('%H:%M:%S.%f')[:-3]}] DataBackupTask: Backup complete.")




class PrintMessageTask(Task):
    def __init__(self, message: str):
        self.message = message

    def execute(self):
        print(f"[{datetime.now().strftime('%H:%M:%S.%f')[:-3]}] Executing PrintMessageTask: {self.message}")








class Task(ABC):
    @abstractmethod
    def execute(self):
        pass




class ScheduledTask:
    def __init__(self, task: Task, strategy: 'SchedulingStrategy'):
        self.id = str(uuid.uuid4())
        self.task = task
        self.strategy = strategy
        self.next_execution_time = None
        self.last_execution_time = None
        self.update_next_execution_time()

    def update_next_execution_time(self):
        next_time = self.strategy.get_next_execution_time(self.last_execution_time)
        self.next_execution_time = next_time

    def update_last_execution_time(self):
        self.last_execution_time = self.next_execution_time

    def __lt__(self, other):
        return self.next_execution_time < other.next_execution_time

    def get_id(self):
        return self.id

    def get_task(self):
        return self.task

    def get_next_execution_time(self):
        return self.next_execution_time

    def has_more_executions(self):
        return self.next_execution_time is not None










def main():
    # 1. Setup the facade and observers
    scheduler = TaskSchedulerService.get_instance()
    scheduler.add_observer(LoggingObserver())

    # 2. Initialize the scheduler
    scheduler.initialize(10)

    # 3. Define tasks and strategies
    # Scenario 1: One-time task, 1 second from now
    one_time_task = PrintMessageTask("This is a one-time task.")
    one_time_strategy = OneTimeSchedulingStrategy(datetime.now() + timedelta(seconds=1))

    # Scenario 2: Recurring task, every 2 seconds
    recurring_task = PrintMessageTask("This is a recurring task.")
    recurring_strategy = RecurringSchedulingStrategy(timedelta(seconds=2))

    # Scenario 3: A long-running backup task, scheduled to run in 3 seconds
    backup_task = DataBackupTask("/data/source", "/data/backup")
    long_running_recurring_strategy = OneTimeSchedulingStrategy(datetime.now() + timedelta(seconds=3))

    # 4. Schedule the tasks using the facade
    print("Scheduling tasks...")
    scheduler.schedule(one_time_task, one_time_strategy)
    scheduler.schedule(recurring_task, recurring_strategy)
    scheduler.schedule(backup_task, long_running_recurring_strategy)

    # 5. Let the demo run for a while
    print("Scheduler is running. Waiting for tasks to execute... (Demo will run for 6 seconds)")
    time.sleep(6)

    # 6. Shutdown the scheduler
    scheduler.shutdown()

if __name__ == "__main__":
    main()











class TaskSchedulerService:
    _instance = None
    _lock = threading.Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super(TaskSchedulerService, cls).__new__(cls)
                    cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if not hasattr(self, '_initialized') or not self._initialized:
            self.task_queue = queue.PriorityQueue()
            self.observers = []
            self.workers = []
            self.running = True
            self._initialized = True

    @staticmethod
    def get_instance():
        return TaskSchedulerService()

    def initialize(self, worker_count: int):
        if worker_count <= 0:
            raise ValueError("Worker count must be >= 1")
        self.workers = []
        self.start_workers(worker_count)

    def schedule(self, task: Task, strategy: SchedulingStrategy) -> str:
        scheduled_task = ScheduledTask(task, strategy)
        self.task_queue.put(scheduled_task)
        return scheduled_task.get_id()

    def start_workers(self, worker_count: int):
        for i in range(worker_count):
            worker = threading.Thread(target=self.run_worker, name=f"WorkerThread-{i}", daemon=True)
            self.workers.append(worker)
            worker.start()

    def run_worker(self):
        while self.running:
            try:
                task = self.task_queue.get(timeout=1)
                now = datetime.now()
                wait_time = 0

                if task.get_next_execution_time() > now:
                    wait_time = (task.get_next_execution_time() - now).total_seconds()

                if wait_time > 0:
                    time.sleep(wait_time)

                # Check if a higher-priority task has arrived while we were sleeping
                try:
                    head = self.task_queue.get_nowait()
                    if head < task:
                        self.task_queue.put(task)
                        self.task_queue.put(head)
                        continue
                    else:
                        self.task_queue.put(head)
                except queue.Empty:
                    pass

                self.execute(task)
                self.task_queue.task_done()
            except queue.Empty:
                continue
            except Exception as e:
                print(f"Worker thread error: {e}")
                break

        print(f"{threading.current_thread().name} stopped.")

    def execute(self, task: ScheduledTask):
        for observer in self.observers:
            observer.on_task_started(task)
        
        try:
            task.get_task().execute()
            task.update_last_execution_time()
            for observer in self.observers:
                observer.on_task_completed(task)
        except Exception as e:
            for observer in self.observers:
                observer.on_task_failed(task, e)
            print(f"Task {task.get_id()} failed with error: {str(e)}")
        finally:
            task.update_next_execution_time()
            
            if task.has_more_executions():
                self.task_queue.put(task)
            else:
                print(f"Task {task.get_id()} has no more executions and will not be rescheduled.")

    def shutdown(self):
        self.running = False
        for worker in self.workers:
            worker.join(timeout=1)
        print("Scheduler shut down.")

    def add_observer(self, observer: TaskExecutionObserver):
        self.observers.append(observer)





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































