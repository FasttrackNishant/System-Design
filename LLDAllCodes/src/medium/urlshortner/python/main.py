class EventType(Enum):
    URL_CREATED = "URL_CREATED"
    URL_ACCESSED = "URL_ACCESSED"




class AnalyticsService(Observer):
    def __init__(self):
        self.click_counts: Dict[str, AtomicLong] = {}
        self._lock = Lock()

    def update(self, event_type: EventType, url: ShortenedURL) -> None:
        if event_type == EventType.URL_CREATED:
            with self._lock:
                self.click_counts[url.get_short_key()] = AtomicLong(0)
            print(f"[Analytics] URL Created: Key={url.get_short_key()}, Original={url.get_long_url()}")
        elif event_type == EventType.URL_ACCESSED:
            with self._lock:
                if url.get_short_key() not in self.click_counts:
                    self.click_counts[url.get_short_key()] = AtomicLong(0)
                count = self.click_counts[url.get_short_key()]
            count.increment_and_get()
            print(f"[Analytics] URL Accessed: Key={url.get_short_key()}, Clicks={count.get()}")






class Observer(ABC):
    @abstractmethod
    def update(self, event_type: EventType, url: ShortenedURL) -> None:
        pass







class InMemoryURLRepository(URLRepository):
    def __init__(self):
        self.key_to_url_map: Dict[str, ShortenedURL] = {}
        self.long_url_to_key_map: Dict[str, str] = {}
        self.id_counter = AtomicLong(1)  # Start from 1
        self._lock = Lock()

    def save(self, url: ShortenedURL) -> None:
        with self._lock:
            self.key_to_url_map[url.get_short_key()] = url
            self.long_url_to_key_map[url.get_long_url()] = url.get_short_key()

    def find_by_key(self, key: str) -> Optional[ShortenedURL]:
        with self._lock:
            return self.key_to_url_map.get(key)

    def find_key_by_long_url(self, long_url: str) -> Optional[str]:
        with self._lock:
            return self.long_url_to_key_map.get(long_url)

    def get_next_id(self) -> int:
        return self.id_counter.get_and_increment()

    def exists_by_key(self, key: str) -> bool:
        with self._lock:
            return key in self.key_to_url_map






class URLRepository(ABC):
    @abstractmethod
    def save(self, url: ShortenedURL) -> None:
        pass

    @abstractmethod
    def find_by_key(self, key: str) -> Optional[ShortenedURL]:
        pass

    @abstractmethod
    def find_key_by_long_url(self, long_url: str) -> Optional[str]:
        pass

    @abstractmethod
    def get_next_id(self) -> int:
        pass

    @abstractmethod
    def exists_by_key(self, key: str) -> bool:
        pass







class Base62Strategy(KeyGenerationStrategy):
    BASE62_CHARS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    BASE = 62
    
    # This is the smallest number that will produce a 6-character Base62 string.
    # It's calculated as 62^5.
    MIN_6_CHAR_ID_OFFSET = 916_132_832

    def generate_key(self, id: int) -> str:
        if id == 0:
            return self.BASE62_CHARS[0]

        id_with_offset = id + self.MIN_6_CHAR_ID_OFFSET

        result = []
        while id_with_offset > 0:
            result.append(self.BASE62_CHARS[id_with_offset % self.BASE])
            id_with_offset //= self.BASE
        
        return ''.join(reversed(result))






class KeyGenerationStrategy(ABC):
    @abstractmethod
    def generate_key(self, id: int) -> str:
        pass





class RandomStrategy(KeyGenerationStrategy):
    CHARACTERS = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    KEY_LENGTH = 6

    def generate_key(self, id: int) -> str:
        return ''.join(random.choice(self.CHARACTERS) for _ in range(self.KEY_LENGTH))





class UUIDStrategy(KeyGenerationStrategy):
    KEY_LENGTH = 6

    def generate_key(self, id: int) -> str:
        # Generate a new UUID, remove the hyphens, and take a substring.
        uuid_str = str(uuid.uuid4()).replace("-", "")
        # Return the first part of the UUID.
        return uuid_str[:self.KEY_LENGTH]










class ShortenedURL:
    def __init__(self, builder):
        self.long_url = builder.long_url
        self.short_key = builder.short_key
        self.creation_date = builder.creation_date

    def get_long_url(self) -> str:
        return self.long_url

    def get_short_key(self) -> str:
        return self.short_key

    def get_creation_date(self) -> datetime:
        return self.creation_date

    class Builder:
        def __init__(self, long_url: str, short_key: str):
            self.long_url = long_url
            self.short_key = short_key
            self.creation_date = datetime.now()

        def creation_date(self, creation_date: datetime):
            self.creation_date = creation_date
            return self

        def build(self) -> 'ShortenedURL':
            return ShortenedURL(self)








def resolve_and_print(shortener: URLShortenerService, short_url: str) -> None:
    resolved_url = shortener.resolve(short_url)
    if resolved_url is not None:
        print(f"Resolved {short_url} -> {resolved_url}")
    else:
        print(f"No original URL found for {short_url}")

def main():
    # --- 1. Setup Phase ---
    # Get the Singleton instance of our service
    shortener = URLShortenerService.get_instance()

    # Configure the service with the chosen strategy and repository
    shortener.configure("http://short.ly/", InMemoryURLRepository(), RandomStrategy())
    shortener.add_observer(AnalyticsService())

    print("--- URL Shortener Service Initialized ---\n")

    # --- 2. Usage Phase ---
    original_url1 = "https://www.verylongurl.com/with/lots/of/path/segments/and/query/params?id=123&user=test"
    print("Shortening: " + original_url1)
    short_url1 = shortener.shorten(original_url1)
    print("Generated Short URL: " + short_url1)
    print()

    # Shorten the same URL again
    print("Shortening the same URL again...")
    short_url2 = shortener.shorten(original_url1)
    print("Generated Short URL: " + short_url2)
    if short_url1 == short_url2:
        print("SUCCESS: The system correctly returned the existing short URL.\n")

    # Shorten a different URL
    original_url2 = "https://www.anotherdomain.com/page.html"
    print("Shortening: " + original_url2)
    short_url3 = shortener.shorten(original_url2)
    print("Generated Short URL: " + short_url3)
    print()

    # --- 3. Resolution Phase ---
    print("--- Resolving and Tracking Clicks ---")

    # Resolve the first URL multiple times
    resolve_and_print(shortener, short_url1)
    resolve_and_print(shortener, short_url1)
    resolve_and_print(shortener, short_url3)

    # Try to resolve a non-existent URL
    print("\nResolving a non-existent URL...")
    resolve_and_print(shortener, "http://short.ly/nonexistent")

if __name__ == "__main__":
    main()









class URLShortenerService:
    _instance = None
    _lock = Lock()

    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
                    cls._instance._initialized = False
        return cls._instance

    def __init__(self):
        if not hasattr(self, '_initialized') or not self._initialized:
            self.url_repository = None
            self.key_generation_strategy = None
            self.domain = None
            self.MAX_RETRIES = 10
            self.observers: List[Observer] = []
            self._initialized = True

    @classmethod
    def get_instance(cls):
        return cls()

    def configure(self, domain: str, repository: URLRepository, strategy: KeyGenerationStrategy) -> None:
        self.domain = domain
        self.url_repository = repository
        self.key_generation_strategy = strategy

    def shorten(self, long_url: str) -> str:
        # Check if we've already shortened this URL
        existing_key = self.url_repository.find_key_by_long_url(long_url)
        if existing_key is not None:
            return self.domain + existing_key

        # Generate a new key, handling potential collisions
        short_key = self._generate_unique_key()

        shortened_url = ShortenedURL.Builder(long_url, short_key).build()
        self.url_repository.save(shortened_url)

        self._notify_observers(EventType.URL_CREATED, shortened_url)

        return self.domain + short_key

    def _generate_unique_key(self) -> str:
        for _ in range(self.MAX_RETRIES):
            # The ID is passed but may be ignored by some strategies (like random)
            potential_key = self.key_generation_strategy.generate_key(self.url_repository.get_next_id())
            if not self.url_repository.exists_by_key(potential_key):
                return potential_key  # Found a unique key
        
        # If we reach here, we failed to generate a unique key after several attempts.
        raise RuntimeError(f"Failed to generate a unique short key after {self.MAX_RETRIES} attempts.")

    def resolve(self, short_url: str) -> Optional[str]:
        if not short_url.startswith(self.domain):
            return None
        
        short_key = short_url.replace(self.domain, "")

        if self.url_repository.exists_by_key(short_key):
            shortened_url = self.url_repository.find_by_key(short_key)
            self._notify_observers(EventType.URL_ACCESSED, shortened_url)
            return short_key

        return None

    def add_observer(self, observer: Observer) -> None:
        self.observers.append(observer)

    def remove_observer(self, observer: Observer) -> None:
        if observer in self.observers:
            self.observers.remove(observer)

    def _notify_observers(self, event_type: EventType, url: ShortenedURL) -> None:
        for observer in self.observers:
            observer.update(event_type, url)
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































