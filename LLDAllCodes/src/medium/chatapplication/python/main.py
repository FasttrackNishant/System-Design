class Chat(ABC):
    def __init__(self):
        self.id = str(uuid.uuid4())
        self.members: List[User] = []
        self.messages: List[Message] = []
        self._lock = Lock()

    def get_id(self) -> str:
        return self.id

    def get_members(self) -> List[User]:
        with self._lock:
            return copy.copy(self.members)

    def get_messages(self) -> List[Message]:
        with self._lock:
            return copy.copy(self.messages)

    def add_message(self, message: Message):
        with self._lock:
            self.messages.append(message)

    @abstractmethod
    def get_name(self, perspective_user: User) -> str:
        pass








class GroupChat(Chat):
    def __init__(self, group_name: str, initial_members: List[User]):
        super().__init__()
        self.group_name = group_name
        self.members.extend(initial_members)

    def add_member(self, user: User):
        with self._lock:
            if user not in self.members:
                self.members.append(user)

    def remove_member(self, user: User):
        with self._lock:
            if user in self.members:
                self.members.remove(user)

    def get_name(self, perspective_user: User) -> str:
        return self.group_name






class OneToOneChat(Chat):
    def __init__(self, user1: User, user2: User):
        super().__init__()
        self.members.extend([user1, user2])

    def get_name(self, perspective_user: User) -> str:
        for member in self.members:
            if member != perspective_user:
                return member.get_name()
        return "Unknown Chat"






class Message:
    def __init__(self, sender: User, content: str):
        self.id = str(uuid.uuid4())
        self.sender = sender
        self.content = content
        self.timestamp = datetime.now()

    def get_id(self) -> str:
        return self.id

    def get_sender(self) -> User:
        return self.sender

    def get_content(self) -> str:
        return self.content

    def get_timestamp(self) -> datetime:
        return self.timestamp

    def __str__(self):
        return f"[{self.timestamp}] {self.sender.get_name()}: {self.content}"









class User:
    def __init__(self, name: str):
        self.id = str(uuid.uuid4())
        self.name = name

    def get_id(self) -> str:
        return self.id

    def get_name(self) -> str:
        return self.name

    def on_message_received(self, message: 'Message', chat_context: 'Chat'):
        print(f"[Notification for {self.get_name()} in chat '{chat_context.get_name(self)}'] {message.get_sender().get_name()}: {message.get_content()}")

    def __eq__(self, other):
        if self is other:
            return True
        if other is None or type(self) != type(other):
            return False
        return self.id == other.id

    def __hash__(self):
        return hash(self.id)

    def __str__(self):
        return f"User{{id='{self.id}', name='{self.name}'}}"








class ChatApplicationDemo:
    @staticmethod
    def main():
        # 1. Initialize the Mediator (ChatService)
        chat_service = ChatService()

        # 2. Create and register users
        alice = chat_service.create_user("Alice")
        bob = chat_service.create_user("Bob")
        charlie = chat_service.create_user("Charlie")

        print("--- Users registered in the system ---")
        print()

        # 3. Scenario 1: One-on-one chat between Alice and Bob
        print("--- Starting one-on-one chat between Alice and Bob ---")
        alice_bob_chat = chat_service.create_one_to_one_chat(alice.get_id(), bob.get_id())

        # Alice sends a message to Bob
        print("Alice sends a message...")
        chat_service.send_message(alice.get_id(), alice_bob_chat.get_id(), "Hi Bob, how are you?")

        # Bob sends a reply
        print("\nBob sends a reply...")
        chat_service.send_message(bob.get_id(), alice_bob_chat.get_id(), "I'm good, Alice! Thanks for asking.")
        print()

        # 4. Scenario 2: Group chat
        print("--- Starting a group chat for a 'Project Team' ---")
        project_members = [alice.get_id(), bob.get_id(), charlie.get_id()]
        project_group = chat_service.create_group_chat("Project Team", project_members)

        # Charlie sends a message to the group
        print("Charlie sends a message to the group...")
        chat_service.send_message(charlie.get_id(), project_group.get_id(), "Hey team, when is our deadline?")

        # Alice replies to the group
        print("\nAlice replies to the group...")
        chat_service.send_message(alice.get_id(), project_group.get_id(), "It's next Friday. Let's sync up tomorrow.")
        print()

        # 5. Demonstrate fetching chat history
        print("--- Fetching Chat Histories ---")

        # History of Alice and Bob's chat
        print(f"\nHistory for chat '{alice_bob_chat.get_name(alice)}':")
        one_to_one_history = chat_service.print_chat_history(alice_bob_chat.get_id())
        for message in one_to_one_history:
            print(message)

        # History of the project group chat
        print(f"\nHistory for chat '{project_group.get_name(charlie)}':")
        group_history = chat_service.print_chat_history(project_group.get_id())
        for message in group_history:
            print(message)

        # 6. Demonstrate finding all of a user's chats
        print("\n--- Fetching all of Alice's chats ---")
        alice_chats = chat_service.get_user_chats(alice.get_id())
        for chat in alice_chats:
            print(f"Chat: {chat.get_name(alice)} (ID: {chat.get_id()})")

if __name__ == "__main__":
    ChatApplicationDemo.main()















class ChatService:
    def __init__(self):
        self.users: Dict[str, User] = {}
        self.chats: Dict[str, Chat] = {}
        self._lock = Lock()

    def create_user(self, name: str) -> User:
        user = User(name)
        with self._lock:
            self.users[user.get_id()] = user
        return user

    def create_one_to_one_chat(self, user_id1: str, user_id2: str) -> Chat:
        user1 = self.users.get(user_id1)
        user2 = self.users.get(user_id2)
        chat = OneToOneChat(user1, user2)
        with self._lock:
            self.chats[chat.get_id()] = chat
        return chat

    def create_group_chat(self, name: str, member_ids: List[str]) -> Chat:
        members = []
        for member_id in member_ids:
            members.append(self.users.get(member_id))
        chat = GroupChat(name, members)
        with self._lock:
            self.chats[chat.get_id()] = chat
        return chat

    def send_message(self, sender_id: str, chat_id: str, message_content: str):
        sender = self.users.get(sender_id)
        chat = self.chats.get(chat_id)
        
        if chat is None:
            print(f"Error: Chat not found with ID: {chat_id}")
            return

        if sender not in chat.get_members():
            print(f"Error: Sender {sender.get_name()} is not a member of this chat.")
            return

        message = Message(sender, message_content)
        chat.add_message(message)

        # Notify all members of the chat (Observer pattern)
        for member in chat.get_members():
            # Do not send a notification to the sender
            if member != sender:
                member.on_message_received(message, chat)

    def print_chat_history(self, chat_id: str) -> List[Message]:
        chat = self.chats.get(chat_id)
        if chat is not None:
            return chat.get_messages()
        return []

    def get_user_chats(self, user_id: str) -> List[Chat]:
        user = self.users.get(user_id)
        if user is None:
            return []
        
        result = []
        for chat in self.chats.values():
            if user in chat.get_members():
                result.append(chat)
        return result










































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































