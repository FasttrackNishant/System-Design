package easy.snakeandladder.java;

class FixedWindowStrategy implements RateLimitingStrategy {
    private final int maxRequests;
    private final long windowSizeInMillis;
    private final Map<String, UserRequestInfo> userRequestMap = new ConcurrentHashMap<>();

    public FixedWindowStrategy(int maxRequests, long windowSizeInSeconds) {
        this.maxRequests = maxRequests;
        this.windowSizeInMillis = windowSizeInSeconds * 1000;
    }

    @Override
    public boolean allowRequest(String userId) {
        long currentTime = System.currentTimeMillis();
        userRequestMap.putIfAbsent(userId, new UserRequestInfo(currentTime));

        UserRequestInfo requestInfo = userRequestMap.get(userId);

        synchronized (requestInfo) {
            if (currentTime - requestInfo.windowStart >= windowSizeInMillis) {
                requestInfo.reset(currentTime);
            }

            if (requestInfo.requestCount.get() < maxRequests) {
                requestInfo.requestCount.incrementAndGet();
                return true;
            } else {
                return false;
            }
        }
    }

    private static class UserRequestInfo {
        long windowStart;
        AtomicInteger requestCount;

        UserRequestInfo(long startTime) {
            this.windowStart = startTime;
            this.requestCount = new AtomicInteger(0);
        }

        void reset(long newStart) {
            this.windowStart = newStart;
            this.requestCount.set(0);
        }
    }
}







interface RateLimitingStrategy {
    boolean allowRequest(String userId);
}




class TokenBucketStrategy implements RateLimitingStrategy {
    private final int capacity;
    private final int refillRatePerSecond;
    private final Map<String, TokenBucket> userBuckets = new ConcurrentHashMap<>();

    public TokenBucketStrategy(int capacity, int refillRatePerSecond) {
        this.capacity = capacity;
        this.refillRatePerSecond = refillRatePerSecond;
    }

    @Override
    public boolean allowRequest(String userId) {
        long currentTime = System.currentTimeMillis();
        userBuckets.putIfAbsent(userId, new TokenBucket(capacity, refillRatePerSecond, currentTime));
        TokenBucket bucket = userBuckets.get(userId);

        synchronized (bucket) {
            bucket.refill(currentTime);
            if (bucket.tokens > 0) {
                bucket.tokens--;
                return true;
            } else {
                return false;
            }
        }
    }

    private static class TokenBucket {
        int tokens;
        final int capacity;
        final int refillRatePerSecond;
        long lastRefillTimestamp;

        public TokenBucket(int capacity, int refillRatePerSecond, long currentTimeMillis) {
            this.capacity = capacity;
            this.refillRatePerSecond = refillRatePerSecond;
            this.tokens = capacity;
            this.lastRefillTimestamp = currentTimeMillis;
        }

        public void refill(long currentTime) {
            long elapsedTime = currentTime - lastRefillTimestamp;
            int tokensToAdd = (int) ((elapsedTime / 1000.0) * refillRatePerSecond);

            if (tokensToAdd > 0) {
                tokens = Math.min(capacity, tokens + tokensToAdd);
                lastRefillTimestamp = currentTime;
            }
        }
    }
}













import java.util.*;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

public class RateLimiterDemo {
    public static void main(String[] args) {
        String userId = "user123";

        System.out.println("=== Fixed Window Demo ===");
        runFixedWindowDemo(userId);

        System.out.println("\n=== Token Bucket Demo ===");
        runTokenBucketDemo(userId);
    }

    private static void runFixedWindowDemo(String userId) {
        int maxRequests = 5;
        int windowSeconds = 10;

        RateLimitingStrategy fixedWindowStrategy = new FixedWindowStrategy(maxRequests, windowSeconds);
        RateLimiterService service = RateLimiterService.getInstance();
        service.setRateLimitingStrategy(fixedWindowStrategy);

        ExecutorService executor = Executors.newFixedThreadPool(3);

        for (int i = 0; i < 10; i++) {
            executor.submit(() -> service.handleRequest(userId));
            try {
                Thread.sleep(500);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        executor.shutdown();
    }

    private static void runTokenBucketDemo(String userId) {
        int capacity = 5;
        int refillRate = 1; // 1 token per second

        RateLimitingStrategy tokenBucketStrategy = new TokenBucketStrategy(capacity, refillRate);
        RateLimiterService service = RateLimiterService.getInstance();
        service.setRateLimitingStrategy(tokenBucketStrategy);

        ExecutorService executor = Executors.newFixedThreadPool(2);

        // Simulate 10 rapid requests
        for (int i = 0; i < 10; i++) {
            executor.submit(() -> service.handleRequest(userId));
            try {
                Thread.sleep(300); // faster than refill rate
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        }

        executor.shutdown();
    }
}










class RateLimiterService {
    private static RateLimiterService instance;
    private RateLimitingStrategy rateLimitingStrategy;

    private RateLimiterService() {}

    public static synchronized RateLimiterService getInstance() {
        if (instance == null) {
            instance = new RateLimiterService();
        }
        return instance;
    }

    public void setRateLimitingStrategy(RateLimitingStrategy rateLimitingStrategy) {
        this.rateLimitingStrategy = rateLimitingStrategy;
    }

    public void handleRequest(String userId) {
        if (rateLimitingStrategy.allowRequest(userId)) {
            System.out.println("Request from user " + userId + " is allowed");
        } else {
            System.out.println("Request from user " + userId + " is rejected: Rate limit exceeded");
        }
    }
}




























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































