class Document:
    def __init__(self, id: str, title: str, content: str):
        self.id = id
        self.title = title
        self.content = content

    def get_id(self) -> str:
        return self.id

    def get_title(self) -> str:
        return self.title

    def get_content(self) -> str:
        return self.content

    def __str__(self) -> str:
        return f"Document(id={self.id}, title='{self.title}')"






class InvertedIndex:
    def __init__(self):
        self.index: Dict[str, List[Posting]] = defaultdict(list)

    def add(self, term: str, document_id: str, frequency: int):
        postings = self.index.get(term, [])
        postings.append(Posting(document_id, frequency))
        self.index[term] = postings

    def get_postings(self, term: str) -> List[Posting]:
        return self.index.get(term, [])






class Posting:
    def __init__(self, document_id: str, frequency: int):
        self.document_id = document_id
        self.frequency = frequency

    def get_document_id(self) -> str:
        return self.document_id

    def get_frequency(self) -> int:
        return self.frequency









class SearchResult:
    def __init__(self, document: Document, score: float):
        self.document = document
        self.score = score

    def get_document(self) -> Document:
        return self.document

    def get_score(self) -> float:
        return self.score

    def __str__(self) -> str:
        return f"  - {self.document.get_title()} (Score: {self.score:.2f})"







class RankingStrategy(ABC):
    @abstractmethod
    def rank(self, results: List[SearchResult]):
        pass


class ScoreBasedRankingStrategy(RankingStrategy):
    def rank(self, results: List[SearchResult]):
        results.sort(key=lambda x: x.get_score(), reverse=True)



class ScoreThenAlphabeticalRankingStrategy(RankingStrategy):
    def rank(self, results: List[SearchResult]):
        results.sort(key=lambda x: (-x.get_score(), x.get_document().get_title()))









class ScoringStrategy(ABC):
    @abstractmethod
    def calculate_score(self, term: str, posting: Posting, document: Document) -> float:
        pass


class TermFrequencyScoringStrategy(ScoringStrategy):
    def calculate_score(self, term: str, posting: Posting, document: Document) -> float:
        return posting.get_frequency()



class TitleBoostScoringStrategy(ScoringStrategy):
    TITLE_BOOST_FACTOR = 1.5

    def calculate_score(self, term: str, posting: Posting, document: Document) -> float:
        score = posting.get_frequency()
        if term in document.get_title().lower():
            score *= self.TITLE_BOOST_FACTOR
        return score









class DocumentStore:
    def __init__(self):
        self.store: Dict[str, Document] = {}

    def add_document(self, doc: Document):
        self.store[doc.get_id()] = doc

    def get_document(self, doc_id: str) -> Optional[Document]:
        return self.store.get(doc_id)













class SearchEngineDemo:
    @staticmethod
    def main():
        engine = SearchEngine.get_instance()

        documents = [
            Document("doc1", "Java Performance", "Java is a high-performance language. Tuning Java applications is key."),
            Document("doc2", "Introduction to Python", "Python is a versatile language, great for beginners."),
            Document("doc3", "Advanced Java Concepts", "This document covers advanced topics in Java programming."),
            Document("doc4", "Python vs. Java", "A document comparing Python and Java for web development. Java is faster.")
        ]

        print("Indexing documents...")
        engine.index_documents(documents)
        print("Indexing complete.\n")

        print("====== TermFrequency Scoring + ScoreBased Ranking ======")
        engine.set_scoring_strategy(TermFrequencyScoringStrategy())
        engine.set_ranking_strategy(ScoreBasedRankingStrategy())

        SearchEngineDemo.perform_search(engine, "java")
        SearchEngineDemo.perform_search(engine, "language")
        SearchEngineDemo.perform_search(engine, "performance")

        print("\n====== TitleBoost Scoring + Score-then-Alphabetical Ranking ======")
        engine.set_scoring_strategy(TitleBoostScoringStrategy())
        engine.set_ranking_strategy(ScoreThenAlphabeticalRankingStrategy())

        SearchEngineDemo.perform_search(engine, "java")
        SearchEngineDemo.perform_search(engine, "language")
        SearchEngineDemo.perform_search(engine, "performance")

        SearchEngineDemo.perform_search(engine, "paint")

    @staticmethod
    def perform_search(engine: SearchEngine, query: str):
        print(f"--- Searching for: '{query}' ---")
        results = engine.search(query)

        if not results:
            print("  No results found.")
        else:
            for i, result in enumerate(results):
                print(f"Rank {i + 1}:{result}")
        print()

if __name__ == "__main__":
    SearchEngineDemo.main()















class SearchEngine:
    _instance = None

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        if hasattr(self, '_initialized'):
            return
        self._initialized = True
        self.inverted_index = InvertedIndex()
        self.document_store = DocumentStore()
        self.scoring_strategy = None
        self.ranking_strategy = None

    @classmethod
    def get_instance(cls):
        if cls._instance is None:
            cls._instance = cls()
        return cls._instance

    def set_scoring_strategy(self, scoring_strategy: ScoringStrategy):
        self.scoring_strategy = scoring_strategy

    def set_ranking_strategy(self, ranking_strategy: RankingStrategy):
        self.ranking_strategy = ranking_strategy

    def index_documents(self, documents: List[Document]):
        for doc in documents:
            self.index_document(doc)

    def index_document(self, doc: Document):
        self.document_store.add_document(doc)
        term_frequencies: Dict[str, int] = {}

        text = (doc.get_title() + " " + doc.get_content()).lower()
        tokens = re.split(r'\W+', text)

        for token in tokens:
            if token:
                term_frequencies[token] = term_frequencies.get(token, 0) + 1

        for term, frequency in term_frequencies.items():
            self.inverted_index.add(term, doc.get_id(), frequency)

    def search(self, query: str) -> List[SearchResult]:
        processed_query = query.lower()

        postings = self.inverted_index.get_postings(processed_query)

        results = []
        for posting in postings:
            doc = self.document_store.get_document(posting.get_document_id())
            if doc is not None:
                score = self.scoring_strategy.calculate_score(processed_query, posting, doc)
                results.append(SearchResult(doc, score))

        self.ranking_strategy.rank(results)

        return results




































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































