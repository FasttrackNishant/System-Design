package easy.snakeandladder.java;


class Document {
    private final String id;
    private final String title;
    private final String content;

    public Document(String id, String title, String content) {
        this.id = id;
        this.title = title;
        this.content = content;
    }

    public String getId() { return id; }
    public String getTitle() { return title; }
    public String getContent() { return content; }

    @Override
    public String toString() {
        return "Document(id=" + id + ", title='" + title + "')";
    }
}





class InvertedIndex {
    private final Map<String, List<Posting>> index = new HashMap<>();

    public void add(String term, String documentId, int frequency) {
        // Use getOrDefault to handle cases where the term is new.
        List<Posting> postings = index.getOrDefault(term, new ArrayList<>());
        postings.add(new Posting(documentId, frequency));
        index.put(term, postings);
    }

    public List<Posting> getPostings(String term) {
        return index.getOrDefault(term, Collections.emptyList());
    }
}





class Posting {
    private final String documentId;
    private final int frequency;

    public Posting(String documentId, int frequency) {
        this.documentId = documentId;
        this.frequency = frequency;
    }

    public String getDocumentId() { return documentId; }
    public int getFrequency() { return frequency; }
}




class SearchResult {
    private final Document document;
    private final double score;

    public SearchResult(Document document, double score) {
        this.document = document;
        this.score = score;
    }

    public Document getDocument() { return document; }

    public double getScore() { return score; }

    @Override
    public String toString() {
        return "  - " + document.getTitle() + " (Score: " + String.format("%.2f", score) + ")";
    }
}




interface RankingStrategy {
    void rank(List<SearchResult> results);
}



class ScoreBasedRankingStrategy implements RankingStrategy {
    @Override
    public void rank(List<SearchResult> results) {
        // Sorts purely by score in descending order.
        results.sort(Comparator.comparing(SearchResult::getScore).reversed());
    }
}



class ScoreThenAlphabeticalRankingStrategy implements RankingStrategy {
    @Override
    public void rank(List<SearchResult> results) {
        // Create a composite comparator.
        // 1. Primary sort: by score, descending.
        // 2. Secondary sort (for ties): by document title, ascending.
        Comparator<SearchResult> compositeComparator = Comparator
                .comparing(SearchResult::getScore)
                .reversed()
                .thenComparing(result -> result.getDocument().getTitle());

        results.sort(compositeComparator);
    }
}











interface ScoringStrategy {
    double calculateScore(String term, Posting posting, Document document);
}


class TermFrequencyScoringStrategy implements ScoringStrategy {
    @Override
    public double calculateScore(String term, Posting posting, Document document) {
        // The simplest strategy: score is just the term frequency.
        return posting.getFrequency();
    }
}


class TitleBoostScoringStrategy implements ScoringStrategy {
    private static final double TITLE_BOOST_FACTOR = 1.5;

    @Override
    public double calculateScore(String term, Posting posting, Document document) {
        double score = posting.getFrequency();
        // Give a boost if the term appears in the title.
        if (document.getTitle().toLowerCase().contains(term)) {
            score *= TITLE_BOOST_FACTOR;
        }
        return score;
    }
}





class DocumentStore {
    private final Map<String, Document> store = new HashMap<>();

    public void addDocument(Document doc) {
        store.put(doc.getId(), doc);
    }

    public Document getDocument(String docId) {
        return store.get(docId);
    }
}




class SearchEngine {
    private static SearchEngine instance;
    private final InvertedIndex invertedIndex;
    private final DocumentStore documentStore;
    private ScoringStrategy scoringStrategy;
    private RankingStrategy rankingStrategy;

    private SearchEngine() {
        this.invertedIndex = new InvertedIndex();
        this.documentStore = new DocumentStore();
    }

    public static synchronized SearchEngine getInstance() {
        if(instance == null) {
            instance = new SearchEngine();
        }
        return instance;
    }

    public void setScoringStrategy(ScoringStrategy scoringStrategy) {
        this.scoringStrategy = scoringStrategy;
    }

    public void setRankingStrategy(RankingStrategy rankingStrategy) {
        this.rankingStrategy = rankingStrategy;
    }

    public void indexDocuments(List<Document> documents) {
        for (Document doc : documents) {
            indexDocument(doc);
        }
    }

    public void indexDocument(Document doc) {
        documentStore.addDocument(doc);
        Map<String, Integer> termFrequencies = new HashMap<>();

        // Tokenize title and content. Split by non-word characters.
        String text = (doc.getTitle() + " " + doc.getContent()).toLowerCase();
        String[] tokens = text.split("\\W+");

        // Calculate term frequencies for the current document.
        for (String token : tokens) {
            if (!token.isEmpty()) {
                termFrequencies.merge(token, 1, Integer::sum);
            }
        }

        // Add each term and its frequency to the inverted index.
        for (Map.Entry<String, Integer> entry : termFrequencies.entrySet()) {
            invertedIndex.add(entry.getKey(), doc.getId(), entry.getValue());
        }
    }

    public List<SearchResult> search(String query) {
        String processedQuery = query.toLowerCase();

        // 1. Get postings from the inverted index for the query term.
        List<Posting> postings = invertedIndex.getPostings(processedQuery);

        // 2. Map postings to SearchResult objects.
        List<SearchResult> results = new ArrayList<>();
        for (Posting posting : postings) {
            Document doc = documentStore.getDocument(posting.getDocumentId());
            if (doc != null) {
                double score = scoringStrategy.calculateScore(processedQuery, posting, doc);
                results.add(new SearchResult(doc, score));
            }
        }

        rankingStrategy.rank(results);

        return results;
    }
}









import java.util.*;

public class SearchEngineDemo {
    public static void main(String[] args) {
        // 1. Create a Search Engine instance
        SearchEngine engine = SearchEngine.getInstance();

        // 2. Create a predefined set of documents
        List<Document> documents = Arrays.asList(
                new Document("doc1", "Java Performance", "Java is a high-performance language. Tuning Java applications is key."),
                new Document("doc2", "Introduction to Python", "Python is a versatile language, great for beginners."),
                new Document("doc3", "Advanced Java Concepts", "This document covers advanced topics in Java programming."),
                new Document("doc4", "Python vs. Java", "A document comparing Python and Java for web development. Java is faster.")
        );

        // 3. Index the documents
        System.out.println("Indexing documents...");
        engine.indexDocuments(documents);
        System.out.println("Indexing complete.\n");

        System.out.println("====== TermFrequency Scoring + ScoreBased Ranking ======");
        engine.setScoringStrategy(new TermFrequencyScoringStrategy());
        engine.setRankingStrategy(new ScoreBasedRankingStrategy());

        performSearch(engine, "java");
        performSearch(engine, "language");
        performSearch(engine, "performance");

        System.out.println("\n====== TitleBoost Scoring + Score-then-Alphabetical Ranking ======");
        engine.setScoringStrategy(new TitleBoostScoringStrategy());
        engine.setRankingStrategy(new ScoreThenAlphabeticalRankingStrategy());

        performSearch(engine, "java");
        performSearch(engine, "language");
        performSearch(engine, "performance");

        // No results
        performSearch(engine, "paint");
    }

    private static void performSearch(SearchEngine engine, String query) {
        System.out.println("--- Searching for: '" + query + "' ---");
        List<SearchResult> results = engine.search(query);

        if (results.isEmpty()) {
            System.out.println("  No results found.");
        } else {
            for (int i = 0; i < results.size(); i++) {
                System.out.println("Rank " + (i + 1) + ":" + results.get(i));
            }
        }
        System.out.println();
    }
}































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































